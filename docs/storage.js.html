<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: storage.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: storage.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Storage Management Module
 * Handles all localStorage operations with enhanced error handling and validation
 *
 * @author Seima Development Team
 * @version 2.0.0
 * @since 1.8.1
 */

import { config } from './config-manager.js';
import { errorHandler, ErrorCategory, LogLevel } from './error-handler.js';
import { Utils } from './utils.js';

/**
 * Storage Manager class for handling all localStorage operations
 * Provides safe, validated storage with error handling and data validation
 * @class StorageManager
 */
export class StorageManager {
  /**
   * Get custom rooms from storage
   * @static
   * @returns {Array&lt;Object>} Array of custom room objects
   */
  static getCustomRooms() {
    return Utils.getStorageItem(config.get('storage.keys.customRooms'), []);
  }

  /**
   * Set custom rooms in storage
   * @static
   * @param {Array&lt;Object>} rooms - Array of room objects to store
   * @returns {boolean} True if successful
   */
  static setCustomRooms(rooms) {
    return Utils.setStorageItem(config.get('storage.keys.customRooms'), rooms);
  }

  /**
   * Add a new custom room
   * @static
   * @param {string} roomName - Name of the room to add
   * @returns {boolean} True if room was added successfully
   */
  static addCustomRoom(roomName) {
    const customRooms = this.getCustomRooms();
    const sanitizedName = Utils.sanitizeInput(roomName, 50);

    if (!sanitizedName) {return false;}

    // Check if room already exists
    const predefinedRooms = config.get('rooms.predefined', []);
    const allRooms = [...predefinedRooms.map(r => r.name), ...customRooms.map(r => r.name)];
    if (allRooms.includes(sanitizedName)) {return false;}

    customRooms.push({ name: sanitizedName });
    return this.setCustomRooms(customRooms);
  }

  /**
   * Remove a custom room by index
   * @static
   * @param {number} index - Index of the room to remove
   * @returns {boolean} True if room was removed successfully
   */
  static removeCustomRoom(index) {
    const customRooms = this.getCustomRooms();
    if (index >= 0 &amp;&amp; index &lt; customRooms.length) {
      customRooms.splice(index, 1);
      return this.setCustomRooms(customRooms);
    }
    return false;
  }

  /**
   * Get selected products from storage
   * @static
   * @returns {Array&lt;Object>} Array of selected product objects
   */
  static getSelectedProducts() {
    return Utils.getStorageItem(config.get('storage.keys.selectedProducts'), []);
  }

  /**
   * Set selected products in storage
   * @static
   * @param {Array&lt;Object>} products - Array of product objects to store
   * @returns {boolean} True if successful
   */
  static setSelectedProducts(products) {
    return Utils.setStorageItem(config.get('storage.keys.selectedProducts'), products);
  }

  /**
   * Add a product to the selection
   * @static
   * @param {Object} product - Product object to add
   * @param {string} notes - User notes for the product
   * @param {string} room - Room assignment
   * @param {number} quantity - Quantity to add
   * @returns {boolean} True if product was added successfully
   */
  static addProductToSelection(product, notes, room, quantity) {
    try {
      const selectedProducts = this.getSelectedProducts();
      const maxAnnotationLength = config.get('ui.annotationMaxLength', 140);

      const productEntry = {
        id: Utils.generateId(),
        product: Utils.deepClone(product),
        notes: Utils.sanitizeInput(notes, maxAnnotationLength),
        room: Utils.sanitizeInput(room, 50),
        quantity: Math.max(1, parseInt(quantity) || 1),
        timestamp: Date.now()
      };

      selectedProducts.push(productEntry);
      const success = this.setSelectedProducts(selectedProducts);

      if (success) {
        errorHandler.log(`Product added to selection: ${product.OrderCode}`, LogLevel.DEBUG);
      } else {
        errorHandler.handleError({
          message: 'Failed to save product to selection',
          category: ErrorCategory.STORAGE,
          level: LogLevel.WARN
        });
      }

      return success;
    } catch (error) {
      errorHandler.handleError({
        message: 'Error adding product to selection',
        error,
        category: ErrorCategory.STORAGE,
        level: LogLevel.ERROR
      });
      return false;
    }
  }

  static updateProductQuantity(productId, newQuantity) {
    const selectedProducts = this.getSelectedProducts();
    const productIndex = selectedProducts.findIndex(p => p.id === productId);

    if (productIndex !== -1) {
      selectedProducts[productIndex].quantity = Math.max(1, parseInt(newQuantity) || 1);
      return this.setSelectedProducts(selectedProducts);
    }
    return false;
  }

  static updateProductRoom(productId, newRoom) {
    const selectedProducts = this.getSelectedProducts();
    const productIndex = selectedProducts.findIndex(p => p.id === productId);

    if (productIndex !== -1) {
      selectedProducts[productIndex].room = Utils.sanitizeInput(newRoom, 50);
      return this.setSelectedProducts(selectedProducts);
    }
    return false;
  }

  static updateProductNotes(productId, newNotes) {
    const selectedProducts = this.getSelectedProducts();
    const productIndex = selectedProducts.findIndex(p => p.id === productId);

    if (productIndex !== -1) {
      selectedProducts[productIndex].notes = Utils.sanitizeInput(newNotes, config.get('ui.annotationMaxLength', 140));
      return this.setSelectedProducts(selectedProducts);
    }
    return false;
  }

  static removeProductFromSelection(productId) {
    const selectedProducts = this.getSelectedProducts();
    const filteredProducts = selectedProducts.filter(p => p.id !== productId);
    return this.setSelectedProducts(filteredProducts);
  }

  static clearAllSelections() {
    return this.setSelectedProducts([]) &amp;&amp; this.setCustomRooms([]);
  }

  static getSelectionCount() {
    return this.getSelectedProducts().length;
  }

  static getUserSettings() {
    return Utils.getStorageItem(config.get('storage.keys.userPreferences'), {});
  }

  static saveUserSettings(settings) {
    return Utils.setStorageItem(config.get('storage.keys.userPreferences'), settings);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BrowserCompatibilityManager.html">BrowserCompatibilityManager</a></li><li><a href="ConfigManager.html">ConfigManager</a></li><li><a href="ErrorHandler.html">ErrorHandler</a></li><li><a href="ProductGridManager.html">ProductGridManager</a></li><li><a href="SeimaScanner.html">SeimaScanner</a></li><li><a href="StorageManager.html">StorageManager</a></li><li><a href="Utils.html">Utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CONFIG_SCHEMA">CONFIG_SCHEMA</a></li><li><a href="global.html#Environment">Environment</a></li><li><a href="global.html#ErrorCategory">ErrorCategory</a></li><li><a href="global.html#LogLevel">LogLevel</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Aug 16 2025 02:34:06 GMT+0930 (Australian Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
